# SPARQL
## Abstract

This document provides an overview of the SPARQL reference formulation and its natural RDF mappings. The SPARQL reference formulation describes how to access and reference data from a SPARQL endpoint using SPARQL SELECT query. The natural RDF mappings define the process of converting the values bound to variables in a SPARQL query into their corresponding RDF literals, ensuring compatibility and interoperability with RDF standards. 

## Reference Formulation

A <dfn>SPARQL reference formulation</dfn> (`rml:SPARQL`) is a <a data-cite="RML-Core#dfn-reference-formulation">reference formulation</a> that describes how to access and reference data in a <a data-cite="RML-Core#dfn-data-source">data source</a> a SPARQL endpoint using SPARQL SELECT query.

### Reference formulation identifier

The default SPARQL Reference Formulation is a <a data-cite="RML-Core#dfn-reference-formulation">reference formulation</a> identified with the IRI `rml:SPARQL`. The `rml:Source` of the `rml:LogicalSource` should be a SPARQL Service Description declaring the endpoint to which the SPARQL SELECT query, declared in the iterator, is sent.

### Iterator

The `rml:iterator` of a `rml:LogicalSource` with a `rml:SPARQL` reference formulation MUST be a well-formed SPARQL SELECT query.Such a query will yield a solution sequence, which is a list of solutions. A solution is a mapping from a set of variables to a set of RDF terms. In other words, a solution contains a set of variable bindings where a variable refers to at most one RDF term.

The iterator for a logical source with the `rml:SPARQL` always traverses the solution sequence from the first solution to the last. The solutions in such a solution sequence MUST be used to generate the logical iterations for the logical source. The order of the solution of a solution sequence MUST be preserved in the logical iterations. Each variable name in a solution becomes a new SPARQL value that MUST be used as the context for the evaluation of the expression associated with the logical source. 

### Expressions

An expression for expression maps associated with a logical source with the `rml:SPARQL` MUST be expressed as the variable names of a solution. An expression is evaluated against a logical iteration, which is a solution The result of evaluating the expression is an RDF term when the binding exists for a solution. The RDF term obtained MUST be transformed to a list of RDF terms that forms the expression evaluation result. The order in that list naturally preservered as each expression yields at most one result for a solution mapping.

## Natural RDF mapping of SPARQL Solutions
The variable bindings in each solution become the basis for constructing the RDF terms that are generated by the expression maps.

The following table describes the expected behavior when using `rml:reference` in term maps.

| Source RDF Term | Target RDF Term | Directive | Comment |
| -------- | ------- | ------- | -- |
| IRI | IRI | Source IRI is returned. |
| Literal | IRI (OPTION 1) | Let v be the lexical form of the literal. If v is a valid absolute IRI, then return an IRI generated from v. Otherwise, prepend v with the base IRI. If the result is a valid absolute IRI, then return an IRI generated from the result. Otherwise, raise a data error. | 
| Literal | IRI (OPTION 2) | Let v be the literal value of the literal. If v is a valid absolute IRI, then return an IRI generated from v. Otherwise, prepend v with the base IRI. If the result is a valid absolute IRI, then return an IRI generated from the result. Otherwise, raise a data error. | There is no canonical representation for literal values, so I would avoid this.
| Blank Node | IRI | Let v be the blank node's label. Prepend v with the base IRI. If the result is a valid absolute IRI, then return an IRI generated from the result. Otherwise, raise a data error.
| IRI | Literal | Use the IRI string for the generation of the literal.
| Literal | Literal (OPTION 1) | When no language map or datatype map is present, return the source literal. Otherwise, let v be the lexical form of the literal, and use v to generate the RDF term according to the language map or data type map.
| Literal | Literal (OPTION 2) | When no language map or datatype map is present, return the source literal. Otherwise, assess whether the languages or data types generated are compatible with the source term. For example, `"foo"@en` would be incompatible with a term map generating Literals with a different language tag, e.g. "@nl". An integer can be transofrmed into a double, but the inverse must raise a data error. |
| Blank Node | Literal | Let v be the blank node's label, v is used as the basis for the generation of the Literal.
| IRI | Blank Node | Use the IRI string as the seed for a new blank node identifier. Non-absolute IRIs need not be normalized.
| Literal | Blank Node | Use the literal value of the literal as the seed for a new blank node identifier. As such, `"12"`, `"12"@en`, and `12` are associated to diferrent blank node identifiers. Literal term equality is not considered. As such, `"1"^^xsd:integer` and `"01"^^xds:integer` will also refer to two different blank nodes.
| Blank Node | Blank Node | Let v be the blank node's label, v is used as the seed for the generation of the blank node identifier.

When used in a `rml:template`:

| Source RDF Term | Directive | Comment |
| -------- | ------- |-- |
| IRI | Use the IRI string for generating the value of the template-valued expression map.
| Literal (OPTION 1) | Let v be the lexical form of the literal, and use v construct the value of the template-valued expression map.
| Literal (OPTION 2) | Let v be the literal value of the literal, and use v construct the value of the template-valued expression map. | There is no canonical representation for literal values, so I would avoid this.
| Blank Node | Let v be the blank node's label, and use v construct the value of the template-valued expression map.

Important notes :

*  An RML processor should not expect blank node labels in a result set or query to refer to a particular blank node in the data. Blank node labels are scoped to a result set: use of the same blank node label within a result set indicates the same blank node, but the use of the same blank node accross result sets does not.

* The difference between a blank node identifier and a blank node label is that the first refers to identifiers used by RDF processors and the latter is a syntactic convenience used within a specific RDF serialization and SPARQL result sets. A blank node with identifier x in an RDF graph g must be referred to by the same blank node label in a serialization of the graph and result set, but may be referred to be different blank node labels across serializations 


## RDF terminology

This section lists some terms normatively defined in [[RDF11-CONCEPTS]] and used in this document:

- <dfn><a data-cite="RDF11-CONCEPTS#dfn-datatype-iri">Datatype IRI</a></dfn>
- <dfn><a data-cite="RDF11-CONCEPTS#dfn-lexical-form">Lexical form</a></dfn>
- <dfn><a data-cite="RDF11-CONCEPTS#dfn-literal">Literal</a></dfn>

# SPARQL terminology

This section lists some terms normatively defined in SPARQL and used in this document:

- <dfn><a data-cite="SPARQL11-QUERY#select">SELECT (query form)</a></dfn>
- <dfn><a data-cite="SPARQL11-QUERY#defn_sparqlSolutionMapping">Solution Mapping</a></dfn>
- <dfn><a data-cite="SPARQL11-QUERY#defn_sparqlSolutionSequence">Solution Sequence</a></dfn>
- <dfn><a data-cite="SPARQL11-QUERY#defn_RDFTerm">RDF term</a></dfn>
- <dfn><a data-cite="SPARQL11-QUERY#QSynVariables">Variable</a></dfn>